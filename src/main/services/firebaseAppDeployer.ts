import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';

export interface FirebaseConfig {
  apiKey: string;
  authDomain: string;
  projectId: string;
  storageBucket: string;
  messagingSenderId: string;
  appId: string;
  measurementId?: string;
}

export class FirebaseAppDeployer {
  private firebasemanagement = google.firebase('v1beta1');
  
  constructor(private auth: OAuth2Client) {}

  async createFirebaseWebApp(
    projectId: string,
    appName: string,
    displayName: string
  ): Promise<FirebaseConfig> {
    console.log('=== Starting Firebase Web App creation ===');
    console.log(`Project: ${projectId}, App Name: ${appName}`);
    
    try {
      // First, check if Firebase project exists
      const firebaseProject = await this.getOrCreateFirebaseProject(projectId);
      console.log(`Firebase project: ${firebaseProject}`);
      
      // List existing web apps
      const existingApps = await this.listWebApps(projectId);
      console.log(`Found ${existingApps.length} existing web apps`);
      
      // Check if app already exists by display name
      const existingApp = existingApps.find(app => 
        app.displayName === displayName
      );
      
      if (existingApp) {
        console.log(`Web app "${displayName}" already exists`);
        return await this.getWebAppConfig(existingApp.name!);
      }
      
      // Create new web app
      console.log(`Creating new web app "${displayName}"...`);
      const webApp = await this.createWebApp(projectId, displayName);
      console.log(`Web app created: ${webApp.appId}`);
      
      // Get the config
      const config = await this.getWebAppConfig(webApp.name!);
      console.log('Firebase config retrieved successfully');
      
      return config;
    } catch (error: any) {
      console.error('Failed to create Firebase web app:', error);
      if (error.response?.data?.error) {
        console.error('Error details:', JSON.stringify(error.response.data.error, null, 2));
      }
      throw error;
    }
  }
  
  private async getOrCreateFirebaseProject(projectId: string): Promise<string> {
    try {
      // Check if Firebase is already enabled
      const { data: project } = await this.firebasemanagement.projects.get({
        name: `projects/${projectId}`,
        auth: this.auth
      });
      
      if (project.resources) {
        console.log('Firebase already enabled for project');
        return project.name!;
      }
    } catch (error: any) {
      if (error.code === 404) {
        // Firebase not enabled, need to enable it
        console.log('Firebase not enabled, adding Firebase to project...');
        
        const { data: operation } = await this.firebasemanagement.projects.addFirebase({
          project: `projects/${projectId}`,
          auth: this.auth
        });
        
        if (operation.name) {
          console.log('Waiting for Firebase to be added to project...');
          await this.waitForOperation(operation.name);
        }
        
        return `projects/${projectId}`;
      }
      throw error;
    }
    
    return `projects/${projectId}`;
  }
  
  private async listWebApps(projectId: string): Promise<any[]> {
    try {
      const { data } = await this.firebasemanagement.projects.webApps.list({
        parent: `projects/${projectId}`,
        auth: this.auth
      });
      
      return data.apps || [];
    } catch (error: any) {
      console.warn('Failed to list web apps:', error.message);
      return [];
    }
  }
  
  private async createWebApp(
    projectId: string,
    displayName: string
  ): Promise<any> {
    const { data: operation } = await this.firebasemanagement.projects.webApps.create({
      parent: `projects/${projectId}`,
      auth: this.auth,
      requestBody: {
        displayName: displayName
        // appId is auto-generated by Firebase, we cannot set it
      }
    });
    
    if (!operation.name) {
      throw new Error('Failed to create web app - no operation returned');
    }
    
    console.log('Waiting for web app creation to complete (including API key provisioning)...');
    const result = await this.waitForOperation(operation.name);
    
    // Extract the web app from the operation result
    if (result.response) {
      // The response contains the fully created web app
      console.log('Web app creation completed. Response:', JSON.stringify(result.response, null, 2));
      
      // The response should be the WebApp object
      return result.response;
    }
    
    throw new Error('Failed to get created web app details from operation response');
  }
  
  private async getWebAppConfig(webAppName: string): Promise<FirebaseConfig> {
    console.log(`Getting SDK config for web app: ${webAppName}`);
    
    // Get the web app details first to ensure it exists
    const { data: webApp } = await this.firebasemanagement.projects.webApps.get({
      name: webAppName,
      auth: this.auth
    });
    
    console.log('Web app details:', JSON.stringify(webApp, null, 2));
    
    // Extract project ID and app ID from web app name (format: projects/{projectId}/webApps/{appId})
    const parts = webAppName.split('/');
    const projectId = parts[1];
    const appId = webApp.appId || parts[3];
    const apiKeyId = webApp.apiKeyId;
    
    // Get project number once - needed for both SDK config API and messagingSenderId
    const projectNumber = await this.getProjectNumber(projectId);
    
    // First, try to get the SDK config with retries (handles eventual consistency)
    const sdkConfig = await this.getSdkConfigWithRetries(projectId, appId);
    
    if (sdkConfig && sdkConfig.apiKey) {
      console.log('Successfully retrieved SDK config with API key');
      return sdkConfig;
    }
    
    // If SDK config failed or didn't include API key, try the fallback approach
    console.log('SDK config not available or missing API key, falling back to API Keys service...');
    
    if (!apiKeyId) {
      throw new Error('No apiKeyId available to retrieve API key');
    }
    
    // Use the apiKeyId to get the API key directly
    const apiKey = await this.getApiKeyDirectly(projectId, apiKeyId);
    
    // Manually construct the Firebase config
    const finalConfig: FirebaseConfig = {
      apiKey: apiKey,
      authDomain: `${projectId}.firebaseapp.com`,
      projectId: projectId,
      storageBucket: `${projectId}.firebasestorage.app`,
      messagingSenderId: projectNumber,
      appId: appId,
      measurementId: undefined // This would need Analytics to be enabled
    };
    
    console.log('Manually constructed Firebase config:', JSON.stringify(finalConfig, null, 2));
    return finalConfig;
  }
  
  private async getSdkConfigWithRetries(projectId: string, appId: string): Promise<FirebaseConfig | null> {
    const maxRetries = 10;
    const initialDelay = 2000; // 2 seconds
    const maxDelay = 30000; // 30 seconds
    
    // Get project number for messagingSenderId fallback
    const projectNumber = await this.getProjectNumber(projectId);
    
    for (let retry = 0; retry < maxRetries; retry++) {
      try {
        const encodedAppId = encodeURIComponent(appId);
        // The correct endpoint is /config, not /sdkConfig, and it uses project ID, not project number
        const sdkConfigUrl = `https://firebase.googleapis.com/v1beta1/projects/${projectId}/webApps/${encodedAppId}/config`;
        
        console.log(`Attempt ${retry + 1}/${maxRetries}: Fetching SDK config from Firebase Management API...`);
        
        const accessToken = await this.auth.getAccessToken();
        const response = await fetch(sdkConfigUrl, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${accessToken.token}`,
            'Content-Type': 'application/json',
            'x-goog-user-project': projectId  // Required for Firebase Management API quota
          }
        });
        
        if (response.ok) {
          const sdkConfig = await response.json();
          console.log('Raw Firebase SDK config response:', JSON.stringify(sdkConfig, null, 2));
          
          // The SDK config should have all the fields we need including apiKey
          const finalConfig: FirebaseConfig = {
            apiKey: sdkConfig.apiKey || '',
            authDomain: sdkConfig.authDomain || `${projectId}.firebaseapp.com`,
            projectId: sdkConfig.projectId || projectId,
            storageBucket: sdkConfig.storageBucket || `${projectId}.firebasestorage.app`,
            messagingSenderId: sdkConfig.messagingSenderId || projectNumber,
            appId: sdkConfig.appId || appId,
            measurementId: sdkConfig.measurementId || undefined
          };
          
          return finalConfig;
        } else if (response.status === 404 && retry < maxRetries - 1) {
          // Expected due to eventual consistency
          const delay = Math.min(initialDelay * Math.pow(2, retry), maxDelay);
          console.log(`SDK config not yet available (404), waiting ${delay}ms before retry...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        } else {
          const errorText = await response.text();
          console.error(`Failed to get SDK config: ${response.status} ${errorText}`);
          if (retry === maxRetries - 1) {
            console.log('Max retries reached for SDK config');
          }
        }
      } catch (error) {
        console.error(`Error during SDK config fetch attempt ${retry + 1}:`, error);
        if (retry === maxRetries - 1) {
          console.log('Max retries reached due to errors');
        }
      }
    }
    
    return null;
  }
  
  private async getApiKeyDirectly(projectId: string, apiKeyId: string): Promise<string> {
    console.log(`Fetching API key directly using apiKeyId: ${apiKeyId}`);
    
    try {
      const apikeys = google.apikeys('v2');
      
      // Get the API key details
      const { data: keyData } = await apikeys.projects.locations.keys.get({
        name: `projects/${projectId}/locations/global/keys/${apiKeyId}`,
        auth: this.auth
      });
      
      if (keyData.keyString) {
        console.log('Successfully retrieved API key from API Keys service');
        return keyData.keyString;
      }
      
      // If keyString is not immediately available, try getKeyString method
      const { data: keyStringData } = await apikeys.projects.locations.keys.getKeyString({
        name: `projects/${projectId}/locations/global/keys/${apiKeyId}`,
        auth: this.auth
      });
      
      if (keyStringData.keyString) {
        console.log('Successfully retrieved API key string');
        return keyStringData.keyString;
      }
      
      throw new Error('API key string not available');
    } catch (error: any) {
      console.error('Failed to get API key directly:', error);
      throw new Error(`Could not retrieve API key: ${error.message}`);
    }
  }
  
  private async getProjectNumber(projectId: string): Promise<string> {
    try {
      const cloudresourcemanager = google.cloudresourcemanager('v1');
      const { data: project } = await cloudresourcemanager.projects.get({
        projectId: projectId,
        auth: this.auth
      });
      
      console.log(`Retrieved project number: ${project.projectNumber} for project ID: ${projectId}`);
      return project.projectNumber || '';
    } catch (error) {
      console.error('Failed to get project number:', error);
      return '';
    }
  }
  
  
  
  private async waitForOperation(operationName: string): Promise<any> {
    let done = false;
    let retries = 0;
    const maxRetries = 60;
    
    console.log(`Monitoring operation: ${operationName}`);
    
    while (!done && retries < maxRetries) {
      const { data: operation } = await this.firebasemanagement.operations.get({
        name: operationName,
        auth: this.auth
      });
      
      if (operation.done) {
        done = true;
        if (operation.error) {
          console.error('Operation failed:', JSON.stringify(operation.error, null, 2));
          throw new Error(`Operation failed: ${JSON.stringify(operation.error)}`);
        }
        console.log('Operation completed successfully');
        console.log('Operation response:', JSON.stringify(operation.response, null, 2));
        return operation;
      } else {
        if (retries % 3 === 0) { // Log every 15 seconds
          console.log(`Still waiting for Firebase operation... (${retries * 5}s elapsed)`);
          if (operation.metadata) {
            console.log('Operation metadata:', JSON.stringify(operation.metadata, null, 2));
          }
        }
        await new Promise(resolve => setTimeout(resolve, 5000));
        retries++;
      }
    }
    
    if (!done) {
      throw new Error('Firebase operation timed out after 5 minutes');
    }
  }
}