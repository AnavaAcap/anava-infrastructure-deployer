import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';

export interface FirebaseConfig {
  apiKey: string;
  authDomain: string;
  projectId: string;
  storageBucket: string;
  messagingSenderId: string;
  appId: string;
  measurementId?: string;
}

export class FirebaseAppDeployer {
  private firebasemanagement = google.firebase('v1beta1');
  
  constructor(private auth: OAuth2Client) {}

  async createFirebaseWebApp(
    projectId: string,
    appName: string,
    displayName: string
  ): Promise<FirebaseConfig> {
    console.log('=== Starting Firebase Web App creation ===');
    console.log(`Project: ${projectId}, App Name: ${appName}`);
    
    try {
      // First, check if Firebase project exists
      const firebaseProject = await this.getOrCreateFirebaseProject(projectId);
      console.log(`Firebase project: ${firebaseProject}`);
      
      // List existing web apps
      const existingApps = await this.listWebApps(projectId);
      console.log(`Found ${existingApps.length} existing web apps`);
      
      // Check if app already exists by display name
      const existingApp = existingApps.find(app => 
        app.displayName === displayName
      );
      
      if (existingApp) {
        console.log(`Web app "${displayName}" already exists`);
        return await this.getWebAppConfig(existingApp.name!);
      }
      
      // Create new web app
      console.log(`Creating new web app "${displayName}"...`);
      const webApp = await this.createWebApp(projectId, displayName);
      console.log(`Web app created: ${webApp.appId}`);
      
      // Wait a bit for Firebase to fully configure the app
      console.log('Waiting for Firebase to configure the web app...');
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // Get the config
      const config = await this.getWebAppConfig(webApp.name!);
      console.log('Firebase config retrieved successfully');
      
      return config;
    } catch (error: any) {
      console.error('Failed to create Firebase web app:', error);
      if (error.response?.data?.error) {
        console.error('Error details:', JSON.stringify(error.response.data.error, null, 2));
      }
      throw error;
    }
  }
  
  private async getOrCreateFirebaseProject(projectId: string): Promise<string> {
    try {
      // Check if Firebase is already enabled
      const { data: project } = await this.firebasemanagement.projects.get({
        name: `projects/${projectId}`,
        auth: this.auth
      });
      
      if (project.resources) {
        console.log('Firebase already enabled for project');
        return project.name!;
      }
    } catch (error: any) {
      if (error.code === 404) {
        // Firebase not enabled, need to enable it
        console.log('Firebase not enabled, adding Firebase to project...');
        
        const { data: operation } = await this.firebasemanagement.projects.addFirebase({
          project: `projects/${projectId}`,
          auth: this.auth
        });
        
        if (operation.name) {
          console.log('Waiting for Firebase to be added to project...');
          await this.waitForOperation(operation.name);
        }
        
        return `projects/${projectId}`;
      }
      throw error;
    }
    
    return `projects/${projectId}`;
  }
  
  private async listWebApps(projectId: string): Promise<any[]> {
    try {
      const { data } = await this.firebasemanagement.projects.webApps.list({
        parent: `projects/${projectId}`,
        auth: this.auth
      });
      
      return data.apps || [];
    } catch (error: any) {
      console.warn('Failed to list web apps:', error.message);
      return [];
    }
  }
  
  private async createWebApp(
    projectId: string,
    displayName: string
  ): Promise<any> {
    const { data: operation } = await this.firebasemanagement.projects.webApps.create({
      parent: `projects/${projectId}`,
      auth: this.auth,
      requestBody: {
        displayName: displayName
        // appId is auto-generated by Firebase, we cannot set it
      }
    });
    
    if (!operation.name) {
      throw new Error('Failed to create web app - no operation returned');
    }
    
    console.log('Waiting for web app creation to complete...');
    const result = await this.waitForOperation(operation.name);
    
    // Extract the web app from the operation result
    if (result.response && result.response.name) {
      const { data: webApp } = await this.firebasemanagement.projects.webApps.get({
        name: result.response.name,
        auth: this.auth
      });
      
      return webApp;
    }
    
    throw new Error('Failed to get created web app details');
  }
  
  private async getWebAppConfig(webAppName: string): Promise<FirebaseConfig> {
    console.log(`Getting config for web app: ${webAppName}`);
    const { data: configData } = await this.firebasemanagement.projects.webApps.getConfig({
      name: webAppName,
      auth: this.auth
    });
    
    console.log('Raw Firebase config response:', JSON.stringify(configData, null, 2));
    
    // The config data is returned directly in the response
    if (!configData) {
      throw new Error('No config data returned');
    }
    
    // Extract project ID from web app name if not in config
    const projectIdFromName = webAppName.split('/')[1];
    
    // Firebase returns the config directly at the top level
    // Construct auth domain if not provided
    const authDomain = configData.authDomain || `${projectIdFromName}.firebaseapp.com`;
    const storageBucket = configData.storageBucket || `${projectIdFromName}.appspot.com`;
    
    return {
      apiKey: configData.apiKey || '',
      authDomain: authDomain,
      projectId: configData.projectId || projectIdFromName || '',
      storageBucket: storageBucket,
      messagingSenderId: configData.messagingSenderId || '',
      appId: configData.appId || '',
      measurementId: configData.measurementId
    };
  }
  
  private async waitForOperation(operationName: string): Promise<any> {
    let done = false;
    let retries = 0;
    const maxRetries = 60;
    
    while (!done && retries < maxRetries) {
      const { data: operation } = await this.firebasemanagement.operations.get({
        name: operationName,
        auth: this.auth
      });
      
      if (operation.done) {
        done = true;
        if (operation.error) {
          throw new Error(`Operation failed: ${JSON.stringify(operation.error)}`);
        }
        return operation;
      } else {
        if (retries % 3 === 0) { // Log every 15 seconds
          console.log(`Still waiting for Firebase operation... (${retries * 5}s elapsed)`);
        }
        await new Promise(resolve => setTimeout(resolve, 5000));
        retries++;
      }
    }
    
    if (!done) {
      throw new Error('Firebase operation timed out');
    }
  }
}