import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';

export interface FirebaseConfig {
  apiKey: string;
  authDomain: string;
  projectId: string;
  storageBucket: string;
  messagingSenderId: string;
  appId: string;
  measurementId?: string;
}

export class FirebaseAppDeployer {
  private firebasemanagement = google.firebase('v1beta1');
  
  constructor(private auth: OAuth2Client) {}

  async createFirebaseWebApp(
    projectId: string,
    appName: string,
    displayName: string,
    existingStorageBucket?: string
  ): Promise<FirebaseConfig> {
    console.log('=== Starting Firebase Web App creation ===');
    console.log(`Project: ${projectId}, App Name: ${appName}`);
    
    try {
      // First, check if Firebase project exists
      const firebaseProject = await this.getOrCreateFirebaseProject(projectId);
      console.log(`Firebase project: ${firebaseProject}`);
      
      // List existing web apps
      const existingApps = await this.listWebApps(projectId);
      console.log(`Found ${existingApps.length} existing web apps`);
      
      // Check if app already exists by display name
      const existingApp = existingApps.find(app => 
        app.displayName === displayName
      );
      
      if (existingApp) {
        console.log(`Web app "${displayName}" already exists`);
        return await this.getWebAppConfig(existingApp.name!, existingStorageBucket);
      }
      
      // Create new web app
      console.log(`Creating new web app "${displayName}"...`);
      const webApp = await this.createWebApp(projectId, displayName);
      console.log(`Web app created: ${webApp.appId}`);
      
      // Get the config
      const config = await this.getWebAppConfig(webApp.name!, existingStorageBucket);
      console.log('Firebase config retrieved successfully');
      
      return config;
    } catch (error: any) {
      console.error('Failed to create Firebase web app:', error);
      if (error.response?.data?.error) {
        console.error('Error details:', JSON.stringify(error.response.data.error, null, 2));
      }
      throw error;
    }
  }
  
  private async getOrCreateFirebaseProject(projectId: string): Promise<string> {
    try {
      // Check if Firebase is already enabled
      const { data: project } = await this.firebasemanagement.projects.get({
        name: `projects/${projectId}`,
        auth: this.auth
      });
      
      if (project.resources) {
        console.log('Firebase already enabled for project');
        return project.name!;
      }
    } catch (error: any) {
      if (error.code === 404) {
        // Firebase not enabled, need to enable it
        console.log('Firebase not enabled, adding Firebase to project...');
        
        const { data: operation } = await this.firebasemanagement.projects.addFirebase({
          project: `projects/${projectId}`,
          auth: this.auth
        });
        
        if (operation.name) {
          console.log('Waiting for Firebase to be added to project...');
          await this.waitForOperation(operation.name);
        }
        
        return `projects/${projectId}`;
      }
      throw error;
    }
    
    return `projects/${projectId}`;
  }
  
  private async listWebApps(projectId: string): Promise<any[]> {
    try {
      const { data } = await this.firebasemanagement.projects.webApps.list({
        parent: `projects/${projectId}`,
        auth: this.auth
      });
      
      return data.apps || [];
    } catch (error: any) {
      console.warn('Failed to list web apps:', error.message);
      return [];
    }
  }
  
  private async createWebApp(
    projectId: string,
    displayName: string
  ): Promise<any> {
    const { data: operation } = await this.firebasemanagement.projects.webApps.create({
      parent: `projects/${projectId}`,
      auth: this.auth,
      requestBody: {
        displayName: displayName
        // appId is auto-generated by Firebase, we cannot set it
      }
    });
    
    if (!operation.name) {
      throw new Error('Failed to create web app - no operation returned');
    }
    
    console.log('Waiting for web app creation to complete (including API key provisioning)...');
    const result = await this.waitForOperation(operation.name);
    
    // Extract the web app from the operation result
    if (result.response) {
      // The response contains the fully created web app
      console.log('Web app creation completed. Response:', JSON.stringify(result.response, null, 2));
      
      // The response should be the WebApp object
      return result.response;
    }
    
    throw new Error('Failed to get created web app details from operation response');
  }
  
  private async getWebAppConfig(webAppName: string, existingStorageBucket?: string): Promise<FirebaseConfig> {
    console.log(`Getting SDK config for web app: ${webAppName}`);
    if (existingStorageBucket) {
      console.log(`Using provided storage bucket: ${existingStorageBucket}`);
    }
    
    // Get the web app details first to ensure it exists
    const { data: webApp } = await this.firebasemanagement.projects.webApps.get({
      name: webAppName,
      auth: this.auth
    });
    
    console.log('Web app details:', JSON.stringify(webApp, null, 2));
    
    // Extract project ID and app ID from web app name (format: projects/{projectId}/webApps/{appId})
    const parts = webAppName.split('/');
    const projectId = parts[1];
    const appId = webApp.appId || parts[3];
    const apiKeyId = webApp.apiKeyId;
    
    // Get project number once - needed for both SDK config API and messagingSenderId
    const projectNumber = await this.getProjectNumber(projectId);
    
    // First, try to get the SDK config with retries (handles eventual consistency)
    const sdkConfig = await this.getSdkConfigWithRetries(projectId, appId);
    
    if (sdkConfig && sdkConfig.apiKey) {
      console.log('Successfully retrieved SDK config with API key');
      
      // If we have an existing storage bucket from state, use it instead of what SDK config returned
      if (existingStorageBucket) {
        console.log(`Overriding SDK config storageBucket (${sdkConfig.storageBucket}) with state bucket (${existingStorageBucket})`);
        sdkConfig.storageBucket = existingStorageBucket;
      }
      
      return sdkConfig;
    }
    
    // If SDK config failed or didn't include API key, try the fallback approach
    console.log('SDK config not available or missing API key, falling back to API Keys service...');
    
    if (!apiKeyId) {
      throw new Error('No apiKeyId available to retrieve API key');
    }
    
    // Use the apiKeyId to get the API key directly
    const apiKey = await this.getApiKeyDirectly(projectId, apiKeyId);
    
    // Manually construct the Firebase config
    const finalConfig: FirebaseConfig = {
      apiKey: apiKey,
      authDomain: `${projectId}.firebaseapp.com`,
      projectId: projectId,
      storageBucket: existingStorageBucket || `${projectId}.firebasestorage.app`,
      messagingSenderId: projectNumber,
      appId: appId,
      measurementId: undefined // This would need Analytics to be enabled
    };
    
    console.log('Manually constructed Firebase config:', JSON.stringify(finalConfig, null, 2));
    if (existingStorageBucket) {
      console.log(`Used provided storage bucket: ${existingStorageBucket}`);
    } else {
      console.log(`Used fallback storage bucket: ${projectId}.firebasestorage.app`);
    }
    return finalConfig;
  }
  
  private async getSdkConfigWithRetries(projectId: string, appId: string): Promise<FirebaseConfig | null> {
    const maxRetries = 10;
    const initialDelay = 2000; // 2 seconds
    const maxDelay = 30000; // 30 seconds
    
    // Get project number for messagingSenderId fallback
    const projectNumber = await this.getProjectNumber(projectId);
    
    for (let retry = 0; retry < maxRetries; retry++) {
      try {
        const encodedAppId = encodeURIComponent(appId);
        // The correct endpoint is /config, not /sdkConfig, and it uses project ID, not project number
        const sdkConfigUrl = `https://firebase.googleapis.com/v1beta1/projects/${projectId}/webApps/${encodedAppId}/config`;
        
        console.log(`Attempt ${retry + 1}/${maxRetries}: Fetching SDK config from Firebase Management API...`);
        
        const accessToken = await this.auth.getAccessToken();
        const response = await fetch(sdkConfigUrl, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${accessToken.token}`,
            'Content-Type': 'application/json',
            'x-goog-user-project': projectId  // Required for Firebase Management API quota
          }
        });
        
        if (response.ok) {
          const sdkConfig = await response.json();
          console.log('Raw Firebase SDK config response:', JSON.stringify(sdkConfig, null, 2));
          
          // The SDK config should have all the fields we need including apiKey
          const finalConfig: FirebaseConfig = {
            apiKey: sdkConfig.apiKey || '',
            authDomain: sdkConfig.authDomain || `${projectId}.firebaseapp.com`,
            projectId: sdkConfig.projectId || projectId,
            storageBucket: sdkConfig.storageBucket || `${projectId}.firebasestorage.app`,
            messagingSenderId: sdkConfig.messagingSenderId || projectNumber,
            appId: sdkConfig.appId || appId,
            measurementId: sdkConfig.measurementId || undefined
          };
          
          return finalConfig;
        } else if (response.status === 404 && retry < maxRetries - 1) {
          // Expected due to eventual consistency
          const delay = Math.min(initialDelay * Math.pow(2, retry), maxDelay);
          console.log(`SDK config not yet available (404), waiting ${delay}ms before retry...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        } else {
          const errorText = await response.text();
          console.error(`Failed to get SDK config: ${response.status} ${errorText}`);
          if (retry === maxRetries - 1) {
            console.log('Max retries reached for SDK config');
          }
        }
      } catch (error) {
        console.error(`Error during SDK config fetch attempt ${retry + 1}:`, error);
        if (retry === maxRetries - 1) {
          console.log('Max retries reached due to errors');
        }
      }
    }
    
    return null;
  }
  
  private async getApiKeyDirectly(projectId: string, apiKeyId: string): Promise<string> {
    console.log(`Fetching API key directly using apiKeyId: ${apiKeyId}`);
    
    try {
      const apikeys = google.apikeys('v2');
      
      // Get the API key details
      const { data: keyData } = await apikeys.projects.locations.keys.get({
        name: `projects/${projectId}/locations/global/keys/${apiKeyId}`,
        auth: this.auth
      });
      
      if (keyData.keyString) {
        console.log('Successfully retrieved API key from API Keys service');
        return keyData.keyString;
      }
      
      // If keyString is not immediately available, try getKeyString method
      const { data: keyStringData } = await apikeys.projects.locations.keys.getKeyString({
        name: `projects/${projectId}/locations/global/keys/${apiKeyId}`,
        auth: this.auth
      });
      
      if (keyStringData.keyString) {
        console.log('Successfully retrieved API key string');
        return keyStringData.keyString;
      }
      
      throw new Error('API key string not available');
    } catch (error: any) {
      console.error('Failed to get API key directly:', error);
      throw new Error(`Could not retrieve API key: ${error.message}`);
    }
  }
  
  private async getProjectNumber(projectId: string): Promise<string> {
    try {
      const cloudresourcemanager = google.cloudresourcemanager('v1');
      const { data: project } = await cloudresourcemanager.projects.get({
        projectId: projectId,
        auth: this.auth
      });
      
      console.log(`Retrieved project number: ${project.projectNumber} for project ID: ${projectId}`);
      return project.projectNumber || '';
    } catch (error) {
      console.error('Failed to get project number:', error);
      return '';
    }
  }
  
  
  
  private async waitForOperation(operationName: string): Promise<any> {
    let done = false;
    let retries = 0;
    const maxRetries = 60;
    
    console.log(`Monitoring operation: ${operationName}`);
    
    while (!done && retries < maxRetries) {
      const { data: operation } = await this.firebasemanagement.operations.get({
        name: operationName,
        auth: this.auth
      });
      
      if (operation.done) {
        done = true;
        if (operation.error) {
          console.error('Operation failed:', JSON.stringify(operation.error, null, 2));
          throw new Error(`Operation failed: ${JSON.stringify(operation.error)}`);
        }
        console.log('Operation completed successfully');
        console.log('Operation response:', JSON.stringify(operation.response, null, 2));
        return operation;
      } else {
        if (retries % 3 === 0) { // Log every 15 seconds
          console.log(`Still waiting for Firebase operation... (${retries * 5}s elapsed)`);
          if (operation.metadata) {
            console.log('Operation metadata:', JSON.stringify(operation.metadata, null, 2));
          }
        }
        await new Promise(resolve => setTimeout(resolve, 5000));
        retries++;
      }
    }
    
    if (!done) {
      throw new Error('Firebase operation timed out after 5 minutes');
    }
  }

  async initializeFirebaseStorage(projectId: string): Promise<void> {
    console.log('=== Initializing Firebase Storage ===');
    
    try {
      // Step 1: Create the default bucket if it doesn't exist
      const storage = google.storage({ version: 'v1', auth: this.auth });
      const defaultBucketName = `${projectId}.appspot.com`;
      
      try {
        await storage.buckets.get({
          bucket: defaultBucketName,
          auth: this.auth
        });
        console.log(`Default storage bucket ${defaultBucketName} already exists`);
      } catch (error: any) {
        if (error.code === 404) {
          console.log(`Creating default storage bucket ${defaultBucketName}...`);
          await storage.buckets.insert({
            project: projectId,
            requestBody: {
              name: defaultBucketName,
              location: 'US',
              storageClass: 'STANDARD'
            },
            auth: this.auth
          });
          console.log('Default storage bucket created');
          
          // Wait for bucket to be ready
          await new Promise(resolve => setTimeout(resolve, 3000));
        } else {
          throw error;
        }
      }
      
      // Step 2: Get project number for service account
      const projectNumber = await this.getProjectNumber(projectId);
      
      // Step 3: Grant Firebase Storage service account admin permissions
      const firebaseStorageServiceAccount = `service-${projectNumber}@gcp-sa-firebasestorage.iam.gserviceaccount.com`;
      console.log(`Granting permissions to Firebase Storage service account: ${firebaseStorageServiceAccount}`);
      
      const cloudResourceManager = google.cloudresourcemanager({ version: 'v1', auth: this.auth });
      const { data: policy } = await cloudResourceManager.projects.getIamPolicy({
        resource: projectId,
        requestBody: {}
      });
      
      // Add Firebase Storage Admin role
      const role = 'roles/firebase.storageAdmin';
      const member = `serviceAccount:${firebaseStorageServiceAccount}`;
      
      let binding = policy.bindings?.find(b => b.role === role);
      if (!binding) {
        binding = { role, members: [] };
        policy.bindings = policy.bindings || [];
        policy.bindings.push(binding);
      }
      
      if (!binding.members?.includes(member)) {
        binding.members = binding.members || [];
        binding.members.push(member);
        
        await cloudResourceManager.projects.setIamPolicy({
          resource: projectId,
          requestBody: { policy }
        });
        console.log('Granted Firebase Storage Admin role');
      }
      
      // Step 4: Finalize the default bucket with Firebase
      console.log('Finalizing Firebase Storage initialization...');
      const finalizeUrl = `https://firebase.googleapis.com/v1beta1/projects/${projectId}/defaultBucket:finalize`;
      
      const accessToken = await this.auth.getAccessToken();
      const response = await fetch(finalizeUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${accessToken.token}`,
          'Content-Type': 'application/json',
          'x-goog-user-project': projectId
        },
        body: JSON.stringify({})
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.warn(`Firebase Storage finalization returned: ${response.status} ${errorText}`);
        // Don't throw error as it might already be initialized
      } else {
        console.log('Firebase Storage initialized successfully!');
      }
      
    } catch (error: any) {
      console.error('Failed to initialize Firebase Storage:', error);
      console.log('⚠️  Firebase Storage may need to be initialized manually in the Firebase Console');
      // Don't throw - allow deployment to continue
    }
  }

  async enableAuthentication(projectId: string): Promise<void> {
    console.log('=== Enabling Firebase Authentication ===');
    
    try {
      // Enable Email/Password authentication provider
      const configUrl = `https://identitytoolkit.googleapis.com/admin/v2/projects/${projectId}/config`;
      
      // First get current config
      const accessToken = await this.auth.getAccessToken();
      const getResponse = await fetch(configUrl, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${accessToken.token}`,
          'x-goog-user-project': projectId
        }
      });
      
      if (!getResponse.ok) {
        const errorText = await getResponse.text();
        console.error(`Failed to get auth config: ${getResponse.status} ${errorText}`);
        throw new Error('Failed to get authentication config');
      }
      
      const currentConfig = await getResponse.json();
      console.log('Current auth config:', JSON.stringify(currentConfig, null, 2));
      
      // Check if email/password is already enabled
      const signInProviders = currentConfig.signIn?.email || {};
      if (signInProviders.enabled) {
        console.log('Email/Password authentication is already enabled');
        return;
      }
      
      // Update config to enable email/password
      const updateMask = 'signIn.email.enabled,signIn.email.passwordRequired';
      const patchUrl = `${configUrl}?updateMask=${encodeURIComponent(updateMask)}`;
      
      const patchResponse = await fetch(patchUrl, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${accessToken.token}`,
          'Content-Type': 'application/json',
          'x-goog-user-project': projectId
        },
        body: JSON.stringify({
          signIn: {
            email: {
              enabled: true,
              passwordRequired: true
            }
          }
        })
      });
      
      if (!patchResponse.ok) {
        const errorText = await patchResponse.text();
        console.error(`Failed to enable authentication: ${patchResponse.status} ${errorText}`);
        throw new Error('Failed to enable email/password authentication');
      }
      
      console.log('✅ Email/Password authentication enabled successfully!');
      
    } catch (error: any) {
      console.error('Failed to enable authentication:', error);
      throw error;
    }
  }

  async createAdminUser(_projectId: string, email: string, password: string, apiKey: string): Promise<string> {
    console.log(`=== Creating admin user: ${email} ===`);
    
    try {
      const createUserUrl = 'https://identitytoolkit.googleapis.com/v1/accounts:signUp';
      
      const response = await fetch(`${createUserUrl}?key=${apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          email,
          password,
          returnSecureToken: true
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        console.error('Failed to create user:', errorData);
        throw new Error(errorData.error?.message || 'Failed to create user');
      }
      
      const userData = await response.json();
      console.log(`✅ Admin user created successfully with UID: ${userData.localId}`);
      
      return userData.localId;
      
    } catch (error: any) {
      console.error('Failed to create admin user:', error);
      throw error;
    }
  }
}