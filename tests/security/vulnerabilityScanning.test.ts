/**
 * Security Testing Suite
 * Vulnerability scanning, dependency checking, and security compliance tests
 */

import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';
import axios from 'axios';

describe('Security Vulnerability Scanning', () => {
  
  describe('Dependency Security Scanning', () => {
    it('should not have critical vulnerabilities in dependencies', async () => {
      // Check for known vulnerabilities using npm audit
      try {
        const auditResult = execSync('npm audit --json', { encoding: 'utf-8' });
        const audit = JSON.parse(auditResult);
        
        // Filter for critical and high severity vulnerabilities
        const criticalVulns = Object.values(audit.vulnerabilities || {}).filter(
          (vuln: any) => vuln.severity === 'critical' || vuln.severity === 'high'
        );
        
        expect(criticalVulns).toHaveLength(0);
      } catch (error: any) {
        // npm audit returns non-zero exit code if vulnerabilities found
        if (error.stdout) {
          const audit = JSON.parse(error.stdout);
          const criticalCount = audit.metadata?.vulnerabilities?.critical || 0;
          const highCount = audit.metadata?.vulnerabilities?.high || 0;
          
          // Fail test if critical or high vulnerabilities exist
          expect(criticalCount).toBe(0);
          expect(highCount).toBe(0);
        }
      }
    });

    it('should not use outdated packages with known vulnerabilities', () => {
      const packageJson = require('../../package.json');
      const vulnerableVersions = {
        'electron': ['<22.0.0'], // Versions before 22 have known security issues
        'axios': ['<0.21.1'],     // SSRF vulnerability
        'firebase': ['<9.0.0'],   // Various security improvements
      };
      
      Object.entries(vulnerableVersions).forEach(([pkg, badVersions]) => {
        const currentVersion = packageJson.dependencies[pkg] || 
                              packageJson.devDependencies[pkg];
        
        if (currentVersion) {
          // Remove ^ or ~ from version
          const cleanVersion = currentVersion.replace(/^[^0-9]*/, '');
          
          badVersions.forEach(badVersion => {
            const threshold = badVersion.replace('<', '');
            expect(compareVersions(cleanVersion, threshold)).toBeGreaterThanOrEqual(0);
          });
        }
      });
    });
  });

  describe('Code Security Patterns', () => {
    const sourceDir = path.join(__dirname, '../../src');
    
    it('should not have hardcoded secrets or API keys', () => {
      const patterns = [
        /api[_-]?key\s*=\s*["'][A-Za-z0-9]{20,}["']/gi,
        /secret\s*=\s*["'][A-Za-z0-9]{20,}["']/gi,
        /password\s*=\s*["'][^"']{8,}["']/gi,
        /token\s*=\s*["'][A-Za-z0-9]{20,}["']/gi,
        /private[_-]?key\s*=\s*["']-----BEGIN/gi,
      ];
      
      const files = getAllFiles(sourceDir, ['.ts', '.tsx', '.js', '.jsx']);
      
      files.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        patterns.forEach(pattern => {
          const matches = content.match(pattern);
          if (matches) {
            // Allow exceptions for test files and mock data
            const isTestFile = file.includes('.test.') || file.includes('.spec.');
            const isMockFile = file.includes('mock') || file.includes('fixture');
            
            if (!isTestFile && !isMockFile) {
              fail(`Potential hardcoded secret found in ${file}: ${matches[0]}`);
            }
          }
        });
      });
    });

    it('should properly validate and sanitize user inputs', () => {
      const files = getAllFiles(sourceDir, ['.ts', '.tsx']);
      
      files.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        // Check for SQL injection vulnerabilities
        const sqlPatterns = [
          /query\s*\(\s*[`"'].*\$\{.*\}.*[`"']/g,
          /exec\s*\(\s*[`"'].*\+.*[`"']/g,
        ];
        
        sqlPatterns.forEach(pattern => {
          const matches = content.match(pattern);
          if (matches) {
            console.warn(`Potential SQL injection risk in ${file}: ${matches[0]}`);
          }
        });
        
        // Check for XSS vulnerabilities in React components
        if (file.endsWith('.tsx')) {
          const dangerousPatterns = [
            /dangerouslySetInnerHTML/g,
            /innerHTML\s*=/g,
          ];
          
          dangerousPatterns.forEach(pattern => {
            const matches = content.match(pattern);
            if (matches) {
              // This is a warning, not a failure, as it might be intentional
              console.warn(`Potential XSS risk in ${file}: ${matches[0]}`);
            }
          });
        }
      });
    });

    it('should use secure communication protocols', () => {
      const files = getAllFiles(sourceDir, ['.ts', '.tsx', '.js']);
      
      files.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        // Check for insecure protocols
        const insecurePatterns = [
          /http:\/\/(?!localhost|127\.0\.0\.1)/g, // HTTP except localhost
          /ftp:\/\//g,
          /telnet:\/\//g,
        ];
        
        insecurePatterns.forEach(pattern => {
          const matches = content.match(pattern);
          if (matches) {
            // Camera IPs might use HTTP for local network
            const isCameraFile = file.includes('camera');
            if (!isCameraFile) {
              fail(`Insecure protocol found in ${file}: ${matches[0]}`);
            }
          }
        });
      });
    });
  });

  describe('Authentication and Authorization', () => {
    it('should implement proper session management', () => {
      const authFiles = getAllFiles(sourceDir, ['.ts']).filter(f => 
        f.includes('auth') || f.includes('Auth')
      );
      
      authFiles.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        // Check for session timeout implementation
        expect(content).toMatch(/timeout|expir/i);
        
        // Check for token refresh logic
        if (content.includes('token')) {
          expect(content).toMatch(/refresh/i);
        }
      });
    });

    it('should properly handle authentication errors', () => {
      const authFiles = getAllFiles(sourceDir, ['.ts']).filter(f => 
        f.includes('auth') || f.includes('Auth')
      );
      
      authFiles.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        // Check for proper error handling
        if (content.includes('authenticate') || content.includes('login')) {
          expect(content).toMatch(/catch|\.catch|try|reject/);
          
          // Should not expose sensitive error details
          const errorPatterns = [
            /console\.log.*password/i,
            /throw.*password/i,
          ];
          
          errorPatterns.forEach(pattern => {
            expect(content).not.toMatch(pattern);
          });
        }
      });
    });
  });

  describe('GCP Security Best Practices', () => {
    it('should use least privilege service accounts', () => {
      const deploymentFiles = getAllFiles(sourceDir, ['.ts']).filter(f => 
        f.includes('deploy') || f.includes('Deploy')
      );
      
      deploymentFiles.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        // Check that we're not using owner or editor roles
        const overPrivilegedRoles = [
          'roles/owner',
          'roles/editor',
          'roles/iam.serviceAccountKeyAdmin', // Should use workload identity instead
        ];
        
        overPrivilegedRoles.forEach(role => {
          if (content.includes(role)) {
            console.warn(`Over-privileged role found in ${file}: ${role}`);
          }
        });
      });
    });

    it('should encrypt sensitive data in transit and at rest', () => {
      const storageFiles = getAllFiles(sourceDir, ['.ts']).filter(f => 
        f.includes('storage') || f.includes('Storage')
      );
      
      storageFiles.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        // Check for encryption settings
        if (content.includes('bucket') || content.includes('Bucket')) {
          // Should use encryption
          const hasEncryption = content.includes('encrypt') || 
                               content.includes('kmsKeyName') ||
                               content.includes('GOOGLE_MANAGED');
          
          if (!hasEncryption) {
            console.warn(`No explicit encryption found in storage file: ${file}`);
          }
        }
      });
    });
  });

  describe('OWASP Top 10 Compliance', () => {
    it('should protect against injection attacks', () => {
      const apiFiles = getAllFiles(sourceDir, ['.ts']).filter(f => 
        f.includes('api') || f.includes('Api') || f.includes('service')
      );
      
      apiFiles.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        // Check for parameterized queries or input validation
        if (content.includes('query') || content.includes('execute')) {
          const hasValidation = content.includes('validate') ||
                               content.includes('sanitize') ||
                               content.includes('escape') ||
                               content.includes('?'); // Parameterized queries
          
          if (!hasValidation) {
            console.warn(`No explicit input validation found in ${file}`);
          }
        }
      });
    });

    it('should implement proper authentication', () => {
      const authContent = fs.readFileSync(
        path.join(sourceDir, 'main/services/gcpOAuthService.ts'),
        'utf-8'
      );
      
      // Check for OAuth2 implementation
      expect(authContent).toMatch(/OAuth2Client/);
      expect(authContent).toMatch(/getAccessToken/);
      
      // Check for token validation
      expect(authContent).toMatch(/verify|validate/i);
    });

    it('should handle sensitive data exposure properly', () => {
      const files = getAllFiles(sourceDir, ['.ts', '.tsx']);
      
      files.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        // Check for logging of sensitive data
        const sensitiveLogging = [
          /console\.(log|error|warn).*password/i,
          /console\.(log|error|warn).*token/i,
          /console\.(log|error|warn).*apiKey/i,
          /console\.(log|error|warn).*secret/i,
        ];
        
        sensitiveLogging.forEach(pattern => {
          const matches = content.match(pattern);
          if (matches) {
            // Allow in test files
            if (!file.includes('.test.') && !file.includes('.spec.')) {
              console.warn(`Potential sensitive data logging in ${file}: ${matches[0]}`);
            }
          }
        });
      });
    });

    it('should have proper error handling without information disclosure', () => {
      const apiFiles = getAllFiles(sourceDir, ['.ts']).filter(f => 
        f.includes('api') || f.includes('Api')
      );
      
      apiFiles.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        // Check for generic error messages
        const detailedErrors = [
          /catch\s*\([^)]+\)\s*{[^}]*res\.(send|json)\([^)]*error\.(stack|message)/g,
          /throw\s+new\s+Error\([^)]*\$\{.*SELECT.*FROM/gi, // SQL in error messages
        ];
        
        detailedErrors.forEach(pattern => {
          const matches = content.match(pattern);
          if (matches) {
            console.warn(`Potential information disclosure in error handling: ${file}`);
          }
        });
      });
    });
  });

  describe('Camera Security', () => {
    it('should use digest authentication for camera communication', () => {
      const cameraFiles = getAllFiles(sourceDir, ['.ts']).filter(f => 
        f.includes('camera')
      );
      
      cameraFiles.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        if (content.includes('axios') || content.includes('request')) {
          // Should implement digest auth
          expect(content).toMatch(/digest|Digest/);
          
          // Should not store plain passwords
          expect(content).not.toMatch(/password\s*=\s*["'][^$][^"']+["']/);
        }
      });
    });

    it('should validate camera IP addresses', () => {
      const cameraFiles = getAllFiles(sourceDir, ['.ts']).filter(f => 
        f.includes('camera')
      );
      
      cameraFiles.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        
        // Should have IP validation
        if (content.includes('ip') || content.includes('IP')) {
          const hasValidation = content.includes('isValidIP') ||
                               content.includes(/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/.source) ||
                               content.includes('net.isIP');
          
          if (!hasValidation) {
            console.warn(`No IP validation found in camera file: ${file}`);
          }
        }
      });
    });
  });
});

// Helper functions
function getAllFiles(dirPath: string, extensions: string[]): string[] {
  const files: string[] = [];
  
  function traverse(currentPath: string) {
    const items = fs.readdirSync(currentPath);
    
    items.forEach(item => {
      const itemPath = path.join(currentPath, item);
      const stat = fs.statSync(itemPath);
      
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
        traverse(itemPath);
      } else if (stat.isFile() && extensions.some(ext => item.endsWith(ext))) {
        files.push(itemPath);
      }
    });
  }
  
  traverse(dirPath);
  return files;
}

function compareVersions(v1: string, v2: string): number {
  const parts1 = v1.split('.').map(Number);
  const parts2 = v2.split('.').map(Number);
  
  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
    const part1 = parts1[i] || 0;
    const part2 = parts2[i] || 0;
    
    if (part1 > part2) return 1;
    if (part1 < part2) return -1;
  }
  
  return 0;
}